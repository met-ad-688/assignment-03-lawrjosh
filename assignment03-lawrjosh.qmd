---
title: Assignment 03
author:
  - name: Joshua Lawrence
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: '2025-9-21'
format:
  html:
    theme: cerulean
    toc: true
    toc-depth: 2
  docx: default
  pdf: default
date-modified: today
date-format: long
---

<!-- 1 Load the Dataset
Load the Raw Dataset:
Use Pyspark to the lightcast_data.csv file into a DataFrame: -->

```{python}
#| eval: true
#| echo: true
#| fig-align: center

import kaleido
import pandas as pd
import plotly.express as px
import plotly.io as pio
from pyspark.sql import SparkSession
import re
import numpy as np
import plotly.graph_objects as go
from pyspark.sql.functions import col, split, explode, regexp_replace, transform, when
from pyspark.sql import functions as F
from pyspark.sql.functions import col, monotonically_increasing_id

np.random.seed(123)

pio.renderers.default = "notebook_connected"

# Initialize Spark Session
spark = SparkSession.builder.appName("LightcastData").getOrCreate()

# Load Data
df = spark.read.option("header", "true").option("inferSchema", "true").option("multiLine","true").option("escape", "\"").csv("data/lightcast_job_postings.csv")
df.createOrReplaceTempView("job_postings")

# # Show Schema and Sample Data
# print("---This is Diagnostic check, No need to print it in the final doc---")

# df.printSchema() # comment this line when rendering the submission
# df.show(5)
```

##  Data Prep / Cleaning

```{python}
#| eval: true
#| echo: true
#| fig-align: center
df = df.withColumn("SALARY_FROM", col("SALARY_FROM").cast("float")) \
.withColumn("SALARY", col("SALARY").cast("float")) \
.withColumn("SALARY_TO", col("SALARY_TO").cast("float")) \
.withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float")) \
.withColumn("MIN_YEARS_EXPERIENCE", col("MIN_YEARS_EXPERIENCE").cast("float"))

def compute_median(sdf, col_name):
    q = sdf.approxQuantile(col_name, [0.5], 0.01)
    return q[0] if q else None

median_from = compute_median(df, "SALARY_FROM")
median_to = compute_median(df, "SALARY_TO")
median_salary = compute_median(df, "SALARY")

print("Medians:", median_from, median_to, median_salary)

df = df.fillna({
  "SALARY_FROM": median_from,
  "SALARY_TO": median_to,
  "SALARY": median_salary
})

df = df.withColumn("Average_Salary", (col("SALARY_FROM") + col("SALARY_TO")) / 2)

export_cols = [
  "EDUCATION_LEVELS_NAME",
  "REMOTE_TYPE_NAME",
  "MAX_YEARS_EXPERIENCE",
  "Average_Salary",
  "SALARY",
  "EMPLOYMENT_TYPE_NAME",
  "LOT_V6_SPECIALIZED_OCCUPATION_NAME",
  "NAICS2_NAME"
]
df_selected = df.select(*export_cols)

pdf = df_selected.toPandas()
pdf.to_csv("./data/lightcast_cleaned.csv", index=False)

print("Data cleaning complete. Rows retained:", len(pdf))

```

## Salary Distribution by Industry and Employment Type

### Data Filtering

```{python}
#| eval: true
#| echo: true
#| fig-align: center
pdf = df_selected.filter(df["SALARY"] > 0).select("EMPLOYMENT_TYPE_NAME", "SALARY", "NAICS2_NAME").toPandas()
pdf = pdf.dropna()

pdf["EMPLOYMENT_TYPE_NAME"] = pdf["EMPLOYMENT_TYPE_NAME"].apply(lambda x: re.sub(r"[^\x00-\x7F]+", "", x))

median_salaries_naics = pdf.groupby("NAICS2_NAME")["SALARY"].median()

top_20_naics = median_salaries_naics.sort_values(ascending=False).head(20).index
pdf = pdf[pdf["NAICS2_NAME"].isin(top_20_naics)]

pdf["NAICS2_NAME"] = pd.Categorical(
    pdf["NAICS2_NAME"],
    categories=top_20_naics,
    ordered=True
)
pdf = pdf[pdf["NAICS2_NAME"].isin(top_20_naics)]

median_salaries = pdf.groupby("EMPLOYMENT_TYPE_NAME")["SALARY"].median()
sorted_employment_types = median_salaries.sort_values(ascending=False).index

pdf["EMPLOYMENT_TYPE_NAME"] = pd.Categorical(
    pdf["EMPLOYMENT_TYPE_NAME"],
    categories=sorted_employment_types,
    ordered=True
)
```

### Chart
```{python}
#| eval: true
#| echo: true
#| fig-align: center
fig = px.box(
  pdf,
  x="NAICS2_NAME",
  y="SALARY",
  labels={
    "NAICS2_NAME": "NAICS Name",
    "SALARY": "Salary"
  },
  color_discrete_sequence=["#4682B4"],
  boxmode="group",
  points="all",
)
fig.update_layout(
  title=dict(
    text="Salary Distribution by Employment Type",
    font=dict(size=30, family="Arial", color="black", weight="bold")
  ),
  xaxis=dict(
    title=dict(text="Employment Type", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickangle=70,
    tickfont=dict(size=10, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=False,
    categoryorder="array",
    categoryarray=sorted_employment_types.tolist()
  ),
  yaxis=dict(
    title=dict(text="Salary (K $)", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickvals=[0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000, 450000, 500000],
    ticktext=["0", "50K", "100K", "150K", "200K", "300K", "350K", "400K", "450K", "500K"],
    tickfont=dict(size=18, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=True,
    gridcolor="lightgray",
    gridwidth=0.5
  ),
  font=dict(family="Arial", size=16, color="black"),
  boxgap=0.7,
  plot_bgcolor="#F5F5F5",
  paper_bgcolor="#DCDCDC",
  showlegend=True,
  height=850,
  width=1300
)
fig.show()
fig.write_html("output/naics_salary.html")
```
### Explanation // Chart Analysis
Salaries vary widely across employment types, with fields like Information and Manufacturing showing higher median salaries compared to sectors like Accommodation and Food Services. Outliers exist in almost all industries, with some individuals earning well above the median levels.

## Salary Analysis by ONET Occupation Type

### Data Filtering // Setup for Chart
```{python}
#| eval: true
#| echo: true
#| fig-align: center
bubble_chart_df = spark.sql("""
    SELECT 
      LOT_V6_SPECIALIZED_OCCUPATION_NAME AS ONET_NAME,
      PERCENTILE(SALARY, 0.5) AS Median_Salary,
      COUNT(*) AS Job_Postings
      FROM job_postings
      GROUP BY LOT_V6_SPECIALIZED_OCCUPATION_NAME
      ORDER BY Job_Postings DESC
      LIMIT 10
""")

bubble_chart_df_pd = bubble_chart_df.toPandas()
bubble_chart_df_pd.head()
```

### Bubble Chart
```{python}
#| eval: true
#| echo: true
#| fig-align: center
import plotly.express as px

fig = px.scatter(
  bubble_chart_df_pd,
  x="ONET_NAME",
  y="Median_Salary",
  size="Job_Postings",
  title="Salary Analysis by LOT Occupation Type",
  labels={
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME": "LOT Occupation",
    "Median_Salary": "Median Salary",
    "Job_Postings": "Number of Job Postings"
  },
  hover_name= "ONET_NAME",
  size_max=60,
  color="Job_Postings",
  color_continuous_scale="emrld"
)
fig.update_layout(
  title=dict(
    text="Median Salary by Occupation Type",
    font=dict(size=24, family="Arial", color="black", weight="bold")
  ),
  xaxis=dict(
    title=dict(text="Occupation Name", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickangle=60,
    tickfont=dict(size=12, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=False,
  ),
  yaxis=dict(
    title=dict(text="Median Salary (k $)", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickvals=[40000, 50000, 60000, 70000, 80000, 90000, 100000, 110000, 120000, 130000, 140000, 150000, 160000, 170000],
    ticktext=["40k", "50k", "60k", "70k", "80k", "90K", "100K", "110K", "120K", "130K", "140k", "150k", "160k", "170k"],
    tickfont=dict(size=12, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=True,
    gridcolor="lightgray",
    gridwidth=0.5
  ),
  font=dict(family="Arial", size=16, color="black"),
  boxgap=0.7,
  plot_bgcolor="white",
  paper_bgcolor="white",
  showlegend=True,
  height=850,
  width=1000
)
fig.show()
fig.write_html("output/bubblechart.html")
```
### Explanation // Chart Analysis
Enterprise Architect and Oracle Consultant roles have the highest median salaries, while Data Analyst positions have the lowest but also the largest number of job postings. Specialized roles generally command higher pay despite fewer postings.

## Salary by Education Level 
### Data Filtering / Setup
```{python}
#| eval: true
#| echo: true
#| fig-align: center
lower_degree = ["Associate", "GED", "No Education Listed", "High School"]
bachelors_degree = ["Bachelor's"]
higher_degree = ["Master's degree", "PhD or professional degree"]

df = df.withColumn(
  "EDU_GROUP",
  when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in lower_degree])), "Associate or lower")
  .when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in bachelors_degree])), "Bachelor's")
  .when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in higher_degree])), "Master's or PhD")
  .otherwise("Other")
)

df = df.filter(
  col("MAX_YEARS_EXPERIENCE").isNotNull() &
  col("Average_Salary").isNotNull() &
  (col("MAX_YEARS_EXPERIENCE") > 0) &
  (col("Average_Salary") > 0)
)

df_filtered = df.filter(col("EDU_GROUP").isin("Associate or lower", "Bachelor's", "Master's or PhD"))

saledu_df = df_filtered.toPandas()
```
### Scatter Plot
```{python}
#| eval: true
#| echo: true
#| fig-align: center
saledufig = px.scatter(
  saledu_df,
  x="MAX_YEARS_EXPERIENCE",
  y="Average_Salary",
  color="EDU_GROUP",
  hover_data=["LOT_V6_SPECIALIZED_OCCUPATION_NAME"],
  opacity=0.7,
  labels = {
    "EDU_GROUP": "Level of Education",
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME": "Occupation Title",
    "Average_Salary": "Average Salary",
    "MAX_YEARS_EXPERIENCE": "Years of Experience"
  },
  color_discrete_sequence=["#B4464B", "#4682B4", "#B4AF46"]
)
saledufig.update_layout(
  title=dict(
    text="Experience vs Salary by Education Level",
    font=dict(size=30, family="Arial", color="black", weight="bold")
  ),
  xaxis=dict(
    title=dict(text="Years of Experience", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickangle=0,
    tickfont=dict(size=12, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=True,
  ),
  yaxis=dict(
    title=dict(text="Average Salary (K $)", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickvals=[0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000, 450000, 500000, 550000, 600000, 650000, 700000, 750000, 800000],
    ticktext=["0", "50k", "100k", "150k", "200k", "250k", "300k", "350k", "400k", "450k", "500k", "550k", "600k", "650k", "700k", "750k", "800k"],
    tickfont=dict(size=12, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=True,
    gridcolor="lightgray",
    gridwidth=0.5
  ),
  font=dict(family="Arial", size=16, color="black"),
  boxgap=0.7,
  plot_bgcolor="#F5F5F5",
  paper_bgcolor="#DCDCDC",
  showlegend=True,
  height=850,
  width=1000
)
saledufig.show()
saledufig.write_html("output/saledufig.html")
```
### Explanation // Chart Analysis
Higher education levels, particularly Master's or PhD, show some instances of higher salaries, though the overall pattern across experience years remains mixed. Many high-earning outliers appear at lower experience levels, suggesting factors beyond experience and education influence pay.

## Salary by Remote Work Type
### Data Filtering / Setup
```{python}
#| eval: true
#| echo: true
#| fig-align: center
Onsite = ["None", "Not Remote"]
Remote = ["Remote"]
Hybrid = ["Hybrid"]

df = df.withColumn(
  "WORK_LOC",
  when(col("REMOTE_TYPE_NAME").rlike("|".join([f"(?i){deg}" for deg in Onsite])), "Onsite")
    .when(col("REMOTE_TYPE_NAME").rlike("|".join([f"(?i){deg}" for deg in Hybrid])), "Hybrid")
    .when(col("REMOTE_TYPE_NAME").rlike("|".join([f"(?i){deg}" for deg in Remote])), "Remote")
  .otherwise("Other")
)

df_filtered = df.filter(col("WORK_LOC").isin("Onsite", "Remote", "Hybrid"))

remote_df = df_filtered.toPandas()
```
### Scatter Plot
```{python}
#| eval: true
#| echo: true
#| fig-align: center
remotefig = px.scatter(
  remote_df,
  x="MAX_YEARS_EXPERIENCE",
  y="Average_Salary",
  color="WORK_LOC",
  hover_data=["LOT_V6_SPECIALIZED_OCCUPATION_NAME"],
  opacity=0.7,
  labels = {
    "WORK_LOC": "Remote Type",
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME": "Occupation Title",
    "Average_Salary": "Average Salary",
    "MAX_YEARS_EXPERIENCE": "Years of Experience"
  },
  color_discrete_sequence=["#B4464B", "#4682B4", "#B4AF46"]
)
remotefig.update_layout(
  title=dict(
    text="Experience vs Salary by Remote Type",
    font=dict(size=30, family="Arial", color="black", weight="bold")
  ),
  xaxis=dict(
    title=dict(text="Years of Experience", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickangle=0,
    tickfont=dict(size=12, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=True,
  ),
  yaxis=dict(
    title=dict(text="Average Salary (k $)", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickvals=[0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000, 450000, 500000, 550000, 600000, 650000, 700000, 750000, 800000],
    ticktext=["0", "50k", "100k", "150k", "200k", "250k", "300k", "350k", "400k", "450k", "500k", "550k", "600k", "650k", "700k", "750k", "800k"],
    tickfont=dict(size=12, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=True,
    gridcolor="lightgray",
    gridwidth=0.5
  ),
  font=dict(family="Arial", size=16, color="black"),
  boxgap=0.7,
  plot_bgcolor="#F5F5F5",
  paper_bgcolor="#DCDCDC",
  showlegend=True,
  height=850,
  width=1000
)
remotefig.show()
remotefig.write_html("output/remotefig.html")
```
### Salary Histograms 
```{python}
fig = px.histogram(
  remote_df, 
  x='SALARY', 
  facet_col='WORK_LOC',
  title='Salary Distribution by Work Location Type',
  labels={'SALARY': 'Salary', 'count': 'Frequency'},
  nbins=20)

fig.update_layout(height=400, showlegend=False)
fig.show()
```
### Explanation // Chart Analysis
Salaries tend to increase slightly with more years of experience, regardless of remote type, but there is significant variability among individual cases. Onsite roles appear to have the highest salary outliers compared to Remote and Hybrid positions.