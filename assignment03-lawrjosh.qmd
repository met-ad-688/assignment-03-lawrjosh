---
title: Assignment 03
author:
  - name: Joshua Lawrence
    affiliations:
      - id: bu
        name: Boston University
        city: Boston
        state: MA
number-sections: true
date: '2025-9-21'
format:
  html:
    theme: cerulean
    toc: true
    toc-depth: 2
  docx: default
  pdf: default
date-modified: today
date-format: long
---

<!-- 1 Load the Dataset
Load the Raw Dataset:
Use Pyspark to the lightcast_data.csv file into a DataFrame: -->

```{python}
#| eval: true
#| echo: true
#| fig-align: center

import pandas as pd
import plotly.express as px
import plotly.io as pio
from pyspark.sql import SparkSession
import re
import numpy as np
import plotly.graph_objects as go
from pyspark.sql.functions import col, split, explode, regexp_replace, transform, when
from pyspark.sql import functions as F
from pyspark.sql.functions import col, monotonically_increasing_id

np.random.seed(123)

pio.renderers.default = "vscode+svg+jpg"

# Initialize Spark Session
spark = SparkSession.builder.appName("LightcastData").getOrCreate()

# Load Data
df = spark.read.option("header", "true").option("inferSchema", "true").option("multiLine","true").option("escape", "\"").csv("data/lightcast_job_postings.csv")
df.createOrReplaceTempView("job_postings")

# # Show Schema and Sample Data
# print("---This is Diagnostic check, No need to print it in the final doc---")

# df.printSchema() # comment this line when rendering the submission
# df.show(5)
```

##  Data Prep / Cleaning

```{python}
df = df.withColumn("SALARY_FROM", col("SALARY_FROM").cast("float")) \
.withColumn("SALARY", col("SALARY").cast("float")) \
.withColumn("SALARY_TO", col("SALARY_TO").cast("float")) \
.withColumn("MAX_YEARS_EXPERIENCE", col("MAX_YEARS_EXPERIENCE").cast("float")) \
.withColumn("MIN_YEARS_EXPERIENCE", col("MIN_YEARS_EXPERIENCE").cast("float"))

def compute_median(sdf, col_name):
    q = sdf.approxQuantile(col_name, [0.5], 0.01)
    return q[0] if q else None

median_from = compute_median(df, "SALARY_FROM")
median_to = compute_median(df, "SALARY_TO")
median_salary = compute_median(df, "SALARY")

print("Medians:", median_from, median_to, median_salary)

df = df.fillna({
  "SALARY_FROM": median_from,
  "SALARY_TO": median_to,
  "SALARY": median_salary
})

df = df.withColumn("Average_Salary", (col("SALARY_FROM") + col("SALARY_TO")) / 2)

export_cols = [
  "EDUCATION_LEVELS_NAME",
  "REMOTE_TYPE_NAME",
  "MAX_YEARS_EXPERIENCE",
  "Average_Salary",
  "SALARY",
  "EMPLOYMENT_TYPE_NAME",
  "LOT_V6_SPECIALIZED_OCCUPATION_NAME"
]
df_selected = df.select(*export_cols)

pdf = df_selected.toPandas()
pdf.to_csv("./data/lightcast_cleaned.csv", index=False)

print("Data cleaning complete. Rows retained:", len(pdf))

```

## Salary Distribution by Industry and Employment Type

### Data Filtering

```{python}
pdf = df_selected.filter(df["SALARY"] > 0).select("EMPLOYMENT_TYPE_NAME", "SALARY").toPandas()
pdf = pdf.dropna()

pdf["EMPLOYMENT_TYPE_NAME"] = pdf["EMPLOYMENT_TYPE_NAME"].apply(lambda x: re.sub(r"[^\x00-\x7F]+", "", x))

median_salaries = pdf.groupby("EMPLOYMENT_TYPE_NAME")["SALARY"].median()
median_salaries.head()

sorted_employment_types = median_salaries.sort_values(ascending=False).index

pdf["EMPLOYMENT_TYPE_NAME"] = pd.Categorical(
  pdf["EMPLOYMENT_TYPE_NAME"],
  categories=sorted_employment_types,
  ordered=True
)
```

### Chart
```{python}
fig = px.box(
  pdf,
  x="EMPLOYMENT_TYPE_NAME",
  y="SALARY",
  title="Salary Distribution by Employment Type",
  color_discrete_sequence=["blue"],
  boxmode="group",
  points="all",
)
fig.update_layout(
  title=dict(
    text="Salary Distribution by Employment Type",
    font=dict(size=30, family="Arial", color="black", weight="bold")
  ),
  xaxis=dict(
    title=dict(text="Employment Type", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickangle=0,
    tickfont=dict(size=18, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=False,
    categoryorder="array",
    categoryarray=sorted_employment_types.tolist()
  ),
  yaxis=dict(
    title=dict(text="Salary (K $)", font=dict(size=24, family="Arial", color="black", weight="bold")),
    tickvals=[0, 50000, 100000, 150000, 200000, 250000, 300000, 350000, 400000, 450000, 500000],
    ticktext=["0", "50K", "100K", "150K", "200K", "300K", "350K", "400K", "450K", "500K"],
    tickfont=dict(size=18, family="Arial", color="black", weight="bold"),
    showline=True,
    linewidth=2,
    linecolor="black",
    mirror=True,
    showgrid=True,
    gridcolor="lightgray",
    gridwidth=0.5
  ),
  font=dict(family="Arial", size=16, color="black"),
  boxgap=0.7,
  plot_bgcolor="white",
  paper_bgcolor="white",
  showlegend=False,
  height=500,
  width=850
)
fig.show(renderer="notebook")
fig.write_html("output/Q1.html")
```
#### Explanation

## Salary Analysis by ONET Occupation Type

### Data Filtering // Setup for Chart
```{python}

bubble_chart_df = spark.sql("""
    SELECT 
      LOT_V6_SPECIALIZED_OCCUPATION_NAME AS ONET_NAME,
      PERCENTILE(SALARY, 0.5) AS Median_Salary,
      COUNT(*) AS Job_Postings
      FROM job_postings
      GROUP BY LOT_V6_SPECIALIZED_OCCUPATION_NAME
      ORDER BY Job_Postings DESC
      LIMIT 10
""")

bubble_chart_df_pd = bubble_chart_df.toPandas()
bubble_chart_df_pd.head()
```

### Bubble Chart
```{python}
import plotly.express as px

fig = px.scatter(
  bubble_chart_df_pd,
  x="ONET_NAME",
  y="Median_Salary",
  size="Job_Postings",
  title="Salary Analysis by LOT Occupation Type",
  labels={
    "LOT_V6_SPECIALIZED_OCCUPATION_NAME": "LOT Occupation",
    "Median_Salary": "Median Salary",
    "Job_Postings": "Number of Job Postings"
  },
  hover_name= "ONET_NAME",
  size_max=60,
  width=1000,
  height=600,
  color="Job_Postings",
  color_continuous_scale="Plasma"
)

fig.show(renderer="notebook")
fig.write_html("output/Q2.html")
```
#### Explanation

## Salary by Education Level 
### Data Filtering / Setup
```{python}
lower_degree = ["Associate", "GED", "No Education Listed", "High School"]
bachelors_degree = ["Bachelor's"]
higher_degree = ["Master's degree", "PhD or professional degree"]

df = df.withColumn(
  "EDU_GROUP",
  when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in lower_degree])), "Associate or lower")
  .when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in bachelors_degree])), "Bachelor's")
  .when(col("EDUCATION_LEVELS_NAME").rlike("|".join([f"(?i){deg}" for deg in higher_degree])), "Master's or PhD")
  .otherwise("Other")
)

df = df.filter(
  col("MAX_YEARS_EXPERIENCE").isNotNull() &
  col("Average_Salary").isNotNull() &
  (col("MAX_YEARS_EXPERIENCE") > 0) &
  (col("Average_Salary") > 0)
)

df_filtered = df.filter(col("EDU_GROUP").isin("Associate or lower", "Bachelor's", "Master's or PhD"))

saledu_df = df_filtered.toPandas()
```
### Scatter Plot
```{python}
saledufig = px.scatter(
  saledu_df,
  x="MAX_YEARS_EXPERIENCE",
  y="Average_Salary",
  color="EDU_GROUP",
  hover_data=["LOT_V6_SPECIALIZED_OCCUPATION_NAME"],
  title="<b>Experience vs Salary by Education Level</b>",
  opacity=0.7,
  color_discrete_sequence=["blanchedalmond", "darkblue", "darkcyan"]
)

saledufig.show(renderer="notebook")
saledufig.write_html("output/saledufig.html")
```
#### Explanation


## Salary by Remote Work Type
### Data Filtering / Setup
```{python}
Onsite = ["None", "Not Remote"]
Remote = ["Remote"]
Hybrid = ["Hybrid"]

df = df.withColumn(
  "WORK_LOC",
  when(col("REMOTE_TYPE_NAME").rlike("|".join([f"(?i){deg}" for deg in Onsite])), "Onsite")
    .when(col("REMOTE_TYPE_NAME").rlike("|".join([f"(?i){deg}" for deg in Hybrid])), "Hybrid")
    .when(col("REMOTE_TYPE_NAME").rlike("|".join([f"(?i){deg}" for deg in Remote])), "Remote")
  .otherwise("Other")
)

df_filtered = df.filter(col("WORK_LOC").isin("Onsite", "Remote", "Hybrid"))

remote_df = df_filtered.toPandas()
```
### Scatter Plot
```{python}
remotefig = px.scatter(
  remote_df,
  x="MAX_YEARS_EXPERIENCE",
  y="Average_Salary",
  color="WORK_LOC",
  hover_data=["LOT_V6_SPECIALIZED_OCCUPATION_NAME"],
  title="<b>Experience vs Salary by Education Level</b>",
  opacity=0.7,
  color_discrete_sequence=["blanchedalmond", "darkblue", "darkcyan"]
)

remotefig.show(renderer="notebook")
remotefig.write_html("output/remotefig.html")
```
#### Explanation
